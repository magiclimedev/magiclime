<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor <%= sensor.name %> - MagicLime</title>
    <link rel="stylesheet" href="/static/css/dashboard.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo-section">
                    <img src="/static/magiclime.png" alt="MagicLime" class="logo">
                    <h1>Sensor Details</h1>
                </div>
                <div class="status-section">
                    <a href="/<%= gateway.serial_num %>" style="background: #667eea; color: white; padding: 8px 16px; border-radius: 6px; text-decoration: none;">
                        ‚Üê Back to Dashboard
                    </a>
                </div>
            </div>
        </header>

        <!-- Sensor Info -->
        <div class="sensor-detail-container" style="background: rgba(255, 255, 255, 0.95); border-radius: 16px; padding: 30px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">
            <h2><%= sensor.name %></h2>
            <div class="sensor-detail-info" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                <div class="info-item">
                    <span class="label">UID:</span>
                    <span class="value"><%= sensor.uid %></span>
                </div>
                <div class="info-item">
                    <span class="label">Type:</span>
                    <span class="value"><%= sensor.type %></span>
                </div>
                <div class="info-item">
                    <span class="label">First Seen:</span>
                    <span class="value"><%= sensor.first_seen || 'Unknown' %></span>
                </div>
                <div class="info-item">
                    <span class="label">Last Seen:</span>
                    <span class="value"><%= sensor.last_seen || 'Unknown' %></span>
                </div>
            </div>
        </div>

        <!-- Chart -->
        <div class="chart-container" style="background: rgba(255, 255, 255, 0.95); border-radius: 16px; padding: 30px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">
            <h3>24-Hour Data History</h3>
            <div style="position: relative; height: 400px; width: 100%;">
                <canvas id="sensor-chart"></canvas>
            </div>
        </div>

        <!-- Recent Logs -->
        <div class="logs-container" style="background: rgba(255, 255, 255, 0.95); border-radius: 16px; padding: 30px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);">
            <h3>Recent Data (Last 10 entries)</h3>
            <div class="logs-table" style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f7fafc;">
                            <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0;">Time</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0;">Data</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0;">Battery</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0;">Signal</th>
                        </tr>
                    </thead>
                    <tbody>
                        <% if (logs && logs.length > 0) { %>
                            <% logs.forEach(log => { %>
                                <tr>
                                    <td style="padding: 12px; border-bottom: 1px solid #e2e8f0;">
                                        <% 
                                        try {
                                            const dateStr = log.created_at || log.createdAt;
                                            let date;
                                            
                                            // Handle different date formats
                                            if (typeof dateStr === 'string' && dateStr.includes('T')) {
                                                // ISO format
                                                date = new Date(dateStr);
                                            } else if (typeof dateStr === 'number') {
                                                // Unix timestamp
                                                date = new Date(dateStr);
                                            } else {
                                                // Try parsing as-is
                                                date = new Date(dateStr);
                                            }
                                            
                                            if (isNaN(date.getTime())) {
                                                throw new Error('Invalid date');
                                            }
                                            
                                            // Format with proper US locale and timezone
                                            const options = {
                                                year: 'numeric',
                                                month: 'numeric', 
                                                day: 'numeric',
                                                hour: 'numeric',
                                                minute: '2-digit',
                                                second: '2-digit',
                                                hour12: true
                                            };
                                            %>
                                            <%= date.toLocaleString('en-US', options) %>
                                        <% } catch(e) { %>
                                            <%= log.created_at || log.createdAt || 'Unknown' %>
                                        <% } %>
                                    </td>
                                    <td style="padding: 12px; border-bottom: 1px solid #e2e8f0;">
                                        <%= typeof log.data === 'object' ? JSON.stringify(log.data) : log.data %>
                                    </td>
                                    <td style="padding: 12px; border-bottom: 1px solid #e2e8f0;">
                                        <%= log.bat ? log.bat + 'V' : 'N/A' %>
                                    </td>
                                    <td style="padding: 12px; border-bottom: 1px solid #e2e8f0;">
                                        <%= log.rss ? log.rss + ' dBm' : 'N/A' %>
                                    </td>
                                </tr>
                            <% }); %>
                        <% } else { %>
                            <tr>
                                <td colspan="4" style="padding: 20px; text-align: center; color: #718096;">
                                    No data available
                                </td>
                            </tr>
                        <% } %>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Initialize chart
        document.addEventListener('DOMContentLoaded', function() {
            const chartData = <%- chartData || '[]' %>;
            
            if (chartData.length > 0) {
                const ctx = document.getElementById('sensor-chart').getContext('2d');
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartData.map((point, index) => {
                            try {
                                // Debug: log the first few points to see what data we have
                                if (index < 3) {
                                    console.log('Chart point data:', point);
                                }
                                
                                const dateStr = point.time || point.created_at || point.createdAt;
                                
                                // If no date field, use index-based time
                                if (!dateStr) {
                                    const now = new Date();
                                    const hoursAgo = Math.floor((chartData.length - index) / (chartData.length / 24));
                                    const estimatedTime = new Date(now.getTime() - (hoursAgo * 60 * 60 * 1000));
                                    return estimatedTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                }
                                
                                let date;
                                if (typeof dateStr === 'string' && dateStr.includes('T')) {
                                    date = new Date(dateStr);
                                } else if (typeof dateStr === 'number') {
                                    date = new Date(dateStr);
                                } else {
                                    date = new Date(dateStr);
                                }
                                
                                if (isNaN(date.getTime())) {
                                    throw new Error('Invalid date');
                                }
                                
                                return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            } catch(e) {
                                // Fallback: create estimated time based on position
                                const now = new Date();
                                const hoursAgo = Math.floor((chartData.length - index) / (chartData.length / 24));
                                const estimatedTime = new Date(now.getTime() - (hoursAgo * 60 * 60 * 1000));
                                return estimatedTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                            }
                        }),
                        datasets: [
                            // Comfort zone background (summer range 72-78¬∞F)
                            {
                                label: 'Comfort Zone',
                                data: chartData.map(() => 78), // Upper comfort limit
                                borderColor: 'rgba(34, 197, 94, 0)', // Transparent border
                                backgroundColor: 'rgba(34, 197, 94, 0.08)', // Light green fill
                                fill: '+1', // Fill to next dataset
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                tension: 0,
                                order: 2
                            },
                            {
                                label: 'Comfort Zone Lower',
                                data: chartData.map(() => 72), // Lower comfort limit
                                borderColor: 'rgba(34, 197, 94, 0)', // Transparent border
                                backgroundColor: 'rgba(34, 197, 94, 0)', // Transparent
                                fill: false,
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                tension: 0,
                                order: 3
                            },
                            // Actual temperature data
                            {
                                label: 'Temperature',
                                data: chartData.map((point, index) => {
                                    // Debug: log the first and last few values
                                    if (index < 3 || index >= chartData.length - 3) {
                                        console.log(`Chart value [${index}]:`, point.value, 'from data:', point);
                                    }
                                    return point.value;
                                }),
                                borderColor: '#2563eb', // Blue for temperature
                                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                                borderWidth: 3,
                                fill: false,
                                tension: 0.4,
                                pointBackgroundColor: '#2563eb',
                                pointBorderColor: '#ffffff',
                                pointBorderWidth: 2,
                                pointRadius: 4,
                                pointHoverRadius: 6,
                                order: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                suggestedMin: (() => {
                                    const values = chartData.map(point => point.value);
                                    const minValue = Math.min(...values);
                                    const maxValue = Math.max(...values);
                                    
                                    // If all data is within 60-80 range, use 60 as min
                                    if (minValue >= 60 && maxValue <= 80) {
                                        return 60;
                                    }
                                    // If data goes below 60, use a bit below the minimum
                                    if (minValue < 60) {
                                        return Math.floor(minValue - 2);
                                    }
                                    // If minimum is above 60 but below 80, still use 60 for better range
                                    return 60;
                                })(),
                                suggestedMax: (() => {
                                    const values = chartData.map(point => point.value);
                                    const minValue = Math.min(...values);
                                    const maxValue = Math.max(...values);
                                    
                                    // If all data is within 60-80 range, use 80 as max
                                    if (minValue >= 60 && maxValue <= 80) {
                                        return 80;
                                    }
                                    // If data goes above 80, use a bit above the maximum
                                    if (maxValue > 80) {
                                        return Math.ceil(maxValue + 2);
                                    }
                                    // If maximum is below 80, still use 80 for better range
                                    return 80;
                                })(),
                                ticks: {
                                    stepSize: 2
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Last 24 Hours'
                            },
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    filter: function(legendItem, chartData) {
                                        // Hide the comfort zone lower boundary from legend
                                        return legendItem.text !== 'Comfort Zone Lower';
                                    },
                                    generateLabels: function(chart) {
                                        const original = Chart.defaults.plugins.legend.labels.generateLabels;
                                        const labels = original.call(this, chart);
                                        
                                        // Customize legend labels
                                        labels.forEach(label => {
                                            if (label.text === 'Comfort Zone') {
                                                label.text = 'Comfort Zone (72-78¬∞F)';
                                            }
                                        });
                                        
                                        return labels;
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        return 'Time: ' + context[0].label;
                                    },
                                    label: function(context) {
                                        if (context.dataset.label === 'Temperature') {
                                            return `Temperature: ${context.parsed.y.toFixed(1)}¬∞F`;
                                        }
                                        return null; // Hide comfort zone tooltips
                                    },
                                    afterLabel: function(context) {
                                        if (context.dataset.label === 'Temperature') {
                                            const temp = context.parsed.y;
                                            if (temp >= 72 && temp <= 78) {
                                                return '‚úì In comfort zone';
                                            } else if (temp < 72) {
                                                return '‚ùÑÔ∏è Below comfort zone';
                                            } else {
                                                return 'üî• Above comfort zone';
                                            }
                                        }
                                        return null;
                                    }
                                },
                                filter: function(tooltipItem) {
                                    // Only show tooltip for temperature data
                                    return tooltipItem.dataset.label === 'Temperature';
                                }
                            }
                        },
                        animation: {
                            duration: 0
                        }
                    }
                });
            } else {
                document.getElementById('sensor-chart').style.display = 'none';
                document.querySelector('.chart-container h3').innerHTML = '24-Hour Data History (No data available)';
            }
        });
    </script>
</body>
</html>